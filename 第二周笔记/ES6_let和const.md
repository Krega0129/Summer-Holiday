1. let：声明变量

   1. 特性：

      1. 变量不能重复声明，会报错。

      2. 具有块级作用域（ES6规定可以在块级作用域中声明函数，相当于let，但是不能在块级作用域外调用）。

      3. 不存在变量提升（我认为是创建过程有提升，初始化以及赋值过程没有提升，原因如下：

         ```js
         alert(a);	//Cannot access 'a' before initialization
         let a = 1;
         ```

         此处报错的是：初始化前无法访问“ a”，即a是已经被创建成功，只是还未初始化。而用var声明变量，则会变量创建、初始化都会被提升；函数声明会函数创建、初始化、赋值都会被提升，所以我们可以在函数声明之前调用函数。参考：[let深入理解---let存在变量提升吗？](https://www.jianshu.com/p/0f49c88cf169))，由于存在暂时性死区，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。（可以认为暂时性死区就是创建变量到初始化之间的区域）

2. const：声明常量

   1. 特性：

      1. 一定要初始化（不初始化会报错），因为常量不能被修改。

      2. 常量一般使用大写（不强制）。

      3. 值不能被修改，指的是变量指向的那个**地址**的数据不能改变，若给一个对象声明为const，即把对象的地址保存在该变量指向的地址中，所以该对象的地址不能改变，但是对象却可以进行修改，如：

         ```js
         const foo = {};
         
         // 为 foo 添加一个属性，可以成功
         foo.prop = 123;
         foo.prop // 123
         
         // 将 foo 指向另一个对象，就会报错
         foo = {}; // TypeError: "foo" is read-only
         ```

      4. 具有块级作用域。

      5. 不具有变量提升，与let一样，也具有暂时性死区。