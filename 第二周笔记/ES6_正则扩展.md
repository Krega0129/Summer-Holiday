1. 正则扩展：

   1. 命名捕获分组：/?<命名>/，此时使用 `exec()` 方法输出的结果其中的 groups 是一个对象，里面的属性就是命名及匹配到的字符串。

   2. 反向（后行）断言：

      1. “先行断言”指的是，`x`只有在`y`前面才匹配，必须写成`/x(?=y)/`。
      2. “先行否定断言”指的是，`x`只有不在`y`前面才匹配，必须写成`/x(?!y)/`。
      3. “后行断言”正好与“先行断言”相反，`x`只有在`y`后面才匹配，必须写成`/(?<=y)x/`。
      4. “后行否定断言”则与“先行否定断言”相反，`x`只有不在`y`后面才匹配，必须写成`/(?<!y)x/`。

   3. 贪婪匹配和懒惰匹配：

      1. 贪婪匹配：正则表达式通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。
      2. 懒惰匹配，也就是匹配尽可能少的字符。在能使整个匹配成功的前提下使用最少的重复，只要在它后面加上一个问号?即可。

      ```js
      let str = 'aabab';
      
      const reg1 = /a.*b/;	//贪婪匹配
      const reg2 = /a.*?b/;	//懒惰匹配
      
      console.log(reg1.exec(str));	//aabab
      console.log(reg2.exec(str));	//aab
      ```

   4. dotAll模式：`/ /s`，之前的元字符 `.` 可以匹配任意一个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用`u`修饰符解决；另一个是行终止符。行终止符包括：

      1. U+000A 换行符（`\n`）
      2. U+000D 回车符（`\r`）
      3. U+2028 行分隔符（line separator）
      4. U+2029 段分隔符（paragraph separator）

      ES2018 引入`s`修饰符，使得`.`可以匹配任意单个字符。这被称为`dotAll`模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个`dotAll`属性，返回一个布尔值，表示该正则表达式是否处在`dotAll`模式。

      ```js
      const reg = /./s;
      console.log(reg.dotAll);	//true
      ```

   5. `String.prototype.matchAll()`：得到正则批量匹配的结果。（转化为可迭代对象，可以用`for...of`循环遍历）
